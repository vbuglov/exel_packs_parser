{"ast":null,"code":"import { cond, drop, includes, T, slice } from \"ramda\";\nimport { prepData, calcs, pack } from \"./exelParser\";\nimport { lib } from \"./data\";\n\nvar withoutNums = function withoutNums(v) {\n  return \"\".concat(v).replace(/[0-9]/gm, \"\");\n};\n\nvar getVFromPack = function getVFromPack(v) {\n  var index = pack()[0].findIndex(function (el) {\n    return el === withoutNums(v);\n  });\n  return pack()[2][index];\n};\n\nvar splitFormula = function splitFormula(str) {\n  return str.replace(/\\(|\\/|\\*|\\-|\\^|\\)/gm, function (v) {\n    return \"__break__\".concat(v, \"__break__\");\n  }).split(\"__break__\").filter(function (el) {\n    return el;\n  });\n};\n\nvar isFormula = function isFormula(str) {\n  return str && str[0] === \"=\";\n};\n\nvar getVFromBook = function getVFromBook(v, book) {\n  if (isFormula(v)) {\n    var formula = v.slice(1).replace(/\\(|\\/|\\*|\\-|\\^|\\)/gm, function (v) {\n      return \"__break__\".concat(v, \"__break__\");\n    }).split(\"__break__\");\n    console.log(formula);\n    return v;\n  }\n\n  return v;\n};\n\nvar getVFromLib = function getVFromLib(v) {\n  var bookName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var splitted = v.replace(/\\$/gm, \"\").split(\".\");\n  var book = lib[bookName || splitted[0]];\n  var field = book[splitted[1]];\n\n  if (isFormula(field)) {\n    return prepParamValue(field, bookName || splitted[0]);\n  }\n\n  return field;\n};\n\nvar prepItem = function prepItem(v) {\n  var bookName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return cond([[function () {\n    return !!bookName;\n  }, function () {\n    return getVFromBook(v, bookName);\n  }], [function () {\n    return includes(\"$\", v) && includes(\".\", v);\n  }, function () {\n    return getVFromLib(v);\n  }], [function () {\n    return pack()[0].includes(withoutNums(v));\n  }, function () {\n    return getVFromPack(v);\n  }], [T, function () {\n    return v;\n  }]])(v);\n};\n\nvar prepSplitted = function prepSplitted() {\n  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var bookName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return arr.map(function (el) {\n    return prepItem(el, bookName);\n  });\n};\n\nvar prepParamValue = function prepParamValue() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var bookName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var splittedStr = splitFormula(value);\n  return prepSplitted(splittedStr, bookName).join(\"\");\n};\n\nvar calcsParser = function calcsParser() {\n  var cols = calcs()[0];\n  var calcsKeys = calcs()[1];\n  var calcsValues = calcs()[2];\n  return \"calcs: [\\n  \".concat(calcsKeys.map(function (el, idx) {\n    return \"%{paramName: \\\"\".concat(el, \"\\\", paramValue: \\\"\").concat(prepParamValue(calcsValues[idx]), \"\\\"},\\n\");\n  }), \"]\");\n};\n\nexport default calcsParser;","map":{"version":3,"sources":["/home/vyc/Documents/packparcerwithcalcs/src/parseExlsPacks/calcsParser.js"],"names":["cond","drop","includes","T","slice","prepData","calcs","pack","lib","withoutNums","v","replace","getVFromPack","index","findIndex","el","splitFormula","str","split","filter","isFormula","getVFromBook","book","formula","console","log","getVFromLib","bookName","splitted","field","prepParamValue","prepItem","prepSplitted","arr","map","value","splittedStr","join","calcsParser","cols","calcsKeys","calcsValues","idx"],"mappings":"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","sourcesContent":["import { cond, drop, includes, T, slice } from \"ramda\";\nimport { prepData, calcs, pack } from \"./exelParser\";\nimport { lib } from \"./data\";\n\nconst withoutNums = (v) => `${v}`.replace(/[0-9]/gm, \"\");\nconst getVFromPack = (v) => {\n  const index = pack()[0].findIndex((el) => el === withoutNums(v));\n  return pack()[2][index];\n};\n\nconst splitFormula = (str) =>\n  str\n    .replace(/\\(|\\/|\\*|\\-|\\^|\\)/gm, (v) => {\n      return `__break__${v}__break__`;\n    })\n    .split(\"__break__\")\n    .filter((el) => el);\n\nconst isFormula = (str) => str && str[0] === \"=\";\n\nconst getVFromBook = (v, book) => {\n  if (isFormula(v)) {\n    const formula = v\n      .slice(1)\n      .replace(/\\(|\\/|\\*|\\-|\\^|\\)/gm, (v) => {\n        return `__break__${v}__break__`;\n      })\n      .split(\"__break__\");\n    console.log(formula);\n    return v;\n  }\n  return v;\n};\n\nconst getVFromLib = (v, bookName = null) => {\n  let splitted = v.replace(/\\$/gm, \"\").split(\".\");\n  const book = lib[bookName || splitted[0]];\n  const field = book[splitted[1]];\n  if (isFormula(field)) {\n    return prepParamValue(field, bookName || splitted[0]);\n  }\n  return field;\n};\n\nconst prepItem = (v, bookName = null) => {\n  return cond([\n    [() => !!bookName, () => getVFromBook(v, bookName)],\n    [() => includes(\"$\", v) && includes(\".\", v), () => getVFromLib(v)],\n    [() => pack()[0].includes(withoutNums(v)), () => getVFromPack(v)],\n    [T, () => v],\n  ])(v);\n};\n\nconst prepSplitted = (arr = [], bookName = null) =>\n  arr.map((el) => prepItem(el, bookName));\n\nconst prepParamValue = (value = \"\", bookName = null) => {\n  const splittedStr = splitFormula(value);\n  return prepSplitted(splittedStr, bookName).join(\"\");\n};\n\nconst calcsParser = () => {\n  const cols = calcs()[0];\n  const calcsKeys = calcs()[1];\n  const calcsValues = calcs()[2];\n  return `calcs: [\n  ${calcsKeys.map(\n    (el, idx) =>\n      `%{paramName: \"${el}\", paramValue: \"${prepParamValue(\n        calcsValues[idx]\n      )}\"},\\n`\n  )}]`;\n};\n\nexport default calcsParser;\n"]},"metadata":{},"sourceType":"module"}